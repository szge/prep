- **function**: a (reusable) sequence of statements designed to do a particular job, executed sequentially
- **function call**: an expression telling the CPU to interrupt the current fn, execute another, and return
- nested functions are not supported in C++
- when the program starts, the OS makes a call to `main()`; it's required to return an `int`, and explicit fn calls to `main` aren't allowed.
- global vars are initialized prior to executing `main()`. if one of their initializers calls a fn, then it will execute before main.
- C++ defines 3 status codes: 0/`EXIT_SUCCESS`, and `EXIT_FAILURE`. they are preprocessor macros defined in `cstdlib`.
- a value-returning fn that doesn't return a value will produce undefined behaviour.
  - the only exception is main, which returns 0 if no return value is specified.
- fns can only return one value
- best practice: don't repeat yourself. use variables to store calculations, functions, and loops
- void functions will cause a compiler error:
  - if used in an expression that requires a value (e.g. `cout << hi()`)
  - if it tries to return a value
- **fn parameter**: variables used in the header of a fn. they are initialized by values provided by the caller.
  - _pass by value_: the value of each argument is copied into the matching parameter (copy initialization)
- the number of arguments provided in the caller must generally match, or there will be a compiler error
- **unreferenced parameters**: parameters that aren't used in the fn body. will generate compiler warning
  - used to differentiate whether a `++` or `--` overload is a prefix (`c++`) or postfix (`++c`) case
- **unnamed parameters**: `void doSomething(int) {}`; could be used in refactoring a fn with many uses
- local variables (defined in fn bodies) are destroyed in the opposite order of creation, at the end of the curly braces it was defined in
  - lifetime is the time between variable creation and destruction. it's runtime property
  - when an object is destroyed, in most cases nothing happens, it just becomes invalid; for class type objects, the destructor is invoked.
  - using an object after destruction is undefined behavior. eventually the memory used by the object will be deallocated
- identifier scope is a compile-time property; using an out-of-scope identifier will cause a compiler error
- names used for parameters or body variables are only visible in that function. this keeps functions independent
- best practice: define local variables as close to their first use as reasonable.
- **temporary object**: an unnamed object used to hold a value needed for a short time
  - e.g. generated by compiler for storing fn return values, after the original has gone out of scope
  - have no scope (they don't have an identifier)
  - destroyed at the end of the full expression where they're created
  - modern C++ (>17) will try to avoid generating temporaries; e.g., it will just initialize a variable directly with a return value
- effectively use functions: group repeated statements, well-defined input&output, one task
- **forward declaration**: a statement telling the compiler that an identifier exists before definition
  - using a forward-declared fn will result in a linker error
  - most often used with fns, but can be used with other identifiers
- **one-definition rule**
  1. within each file, a fn, variable, type, or template in a scope (e.g., fn, namespace) can only have one defn.
     1. violation causes a compiler error
  2. within a program, a fn or variable in a given scope can only have one defn. 
     1. violation causes a linker error
  3. types, templates, inline fn, and inline variables can have duplicate defns in different files, as long as they are identical
     1. violation causes undefined behavior