- control flow statements: allow changing the normal path of execution
- conditional (if, else, switch), jumps (goto, break, continue), fn calls, loops (while, do-while, for, ranged-for), halts (`std::exit()`, `std::abort()`), exceptions (try, throw, catch)
- `if` and `else` statements declare implicit blocks, so don't define variables in them. try to use brackets
- dangling else: an else-statement is paired up with the last unmatched if-statement in the same block.
- null statement: a single semicolon `;`
- `if constexpr ()` statement (C++17): evaluates at compile-time and the compiler will replace the conditional with the appropriate code
- switch statements
  - allow only integral types since they are typically implemented with jump tables for optimization
  - case labels are conventionally not indented since labels don't define a nested scope
  - execution happens sequentially until (1) the end of the switch block (2) another control flow statement, so without a break or return, execution will overflow into subsequent cases
    - the `[[fallthrough]]` attribute (C++17) indicates to the compiler that a fallthrough is intentional
  - initialization of variables is disallowed except in the last case; if a case needs to define and/or initialize a variable, do so in an explicit block `{}`
- goto statements
  - create a statement label (`tryAgain:`); conventionally not indented. `goto tryAgain;`
  - statement labels have fn scope, so it's visible in the fn even before its declaration. label and `goto` must be in the same fn.
  - statement labels must be associated with a statement, so at least put a null statement after it.
  - you can't jump forward over the initialization of a variable
  - avoid using goto!! except maybe when you need to exit a nested loop but not the whole fn
- do-while statements: a while loop except the statement always executes at least once; favour while loops
- for-loops:
  - can use the comma operator to change the value of multiple values in the end-expression
  - variables used only inside a loop should be defined in the loop, to keep scoping small and allow the compiler to optimize
  - avoid unsigned types for loop variables
- `break`
  - signifies a switch case is finished
  - ends a loop early
- `continue` ends the current loop iteration without terminating the loop
- halting (early program exits)
  - when a program exits normally, the `main()` fn returns, all local vars and fn params are destroyed (per usual), and `std::exit()` is called
  - `std::exit()` causes a program to end normally (in an expected way)
    - compare to status codes, which are used to show if the program was successful
    -`std::exit()` performs cleanup fns: objects with static storage are destroyed, file cleanup, control is returned to OS, arg passed to exit used as status code
    - called implicitly at the end of `main()`, but you can also call it explicitly using the `<cstdlib>` header
    - `std::exit()` doesn't clean up local variables!
  - `std::atexit()` allows specifying a fn to be called on program termination (`std::exit()`)
    - multiple registrations are allowed, and they will be called in reverse order of registration (last first)
  - in multithreaded programs, `std::exit()` may cause crashing due to cleanup of static objects possibly used by other threads.
    - instead, use `std::quick_exit()` and `std::at_quick_exit()` that don't clean up static objects
  - `std::abort()` causes an abnormal termination, signaling an unusual runtime error e.g. division by zero. it doesn't do any cleanup
  - `std::terminate()` is usually used with exceptions and calls `std::abort()` by default
  - best practice: only halt if there is no safe way to return normally from main. prefer exceptions for handling errors
- random number generation
  - **seed**: the value used to set the initial state of the PRNG
  - **underseeded**: the PRNG doesn't have enough bits of quality seed data; results in high correlation, or guessing the seed
    - ideally, a seed should contain as many bits as the state of the PRNG, each bit should be independently randomized, and have low correlation with previous seeds
    - avoid underseeding: `std::seed_seq` to pass in as many randomized values as you have
  - use `mt19937` from `<random>` for performance and quality, unless you need extremely high quality random results
  - use the system clock, system random device (`std::random_device`) to seed the PRNG (it's implementation-defined so only use for seeding since it may be expensive)
  - only seed a PRNG once
  - `std::mt19937` performs a warm-up (discarding the initial generated values) after `seed_seq` initialization, so we don't need to explicitly do this.
  - when debugging a program with random numbers, seed the PRNG with a fixed value to replicate the bad behaviour
  - in our `random.h` file, `mt` and supporting fns are `inline`, so we can avoid the ODR as long as all defns are identical (imported from header)
    - we need several helper objects to seed the mt, so we use a helper fn, so we don't need to explicitly call an init fn